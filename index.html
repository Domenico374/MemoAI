<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Memo AI</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- DOCX preview (client-side) -->
  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
  <!-- PDF preview (render first page) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script>
    /* Configura PDF.js (worker obbligatorio per il rendering) */
    window.pdfjsLib = window.pdfjsLib || window['pdfjs-dist/build/pdf'];
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
  </script>
  <style>
    body { background:#f5f7fb }
    .prose :where(h1,h2,h3){margin:.25rem 0 .5rem}
  </style>
</head>
<body class="text-slate-800">
  <div class="max-w-4xl mx-auto p-6">
    <!-- Header -->
    <header class="mb-6 flex items-center justify-between gap-3">
      <div>
        <h1 class="text-3xl font-bold">Memo AI</h1>
        <p class="text-sm text-slate-600">Upload file → Trascrizione / Estrazione → Formattazione</p>
      </div>
      <span id="healthBadge" class="text-xs px-2.5 py-1 rounded-full bg-slate-200 text-slate-700">checking…</span>
    </header>

    <!-- Upload -->
    <section class="bg-white rounded-2xl shadow p-5 mb-6">
      <div class="flex items-start justify-between gap-3">
        <div>
          <h2 class="text-lg font-semibold">Carica file</h2>
          <p class="text-xs text-slate-500 mt-1">
            Suggerimento: per file &gt; 4.5 MB usare versioni ridotte. I PDF scansionati richiederanno OCR.
          </p>
        </div>
        <button id="btnUpload" type="button"
          class="px-3 py-2 rounded-lg text-sm bg-slate-100 hover:bg-slate-200">Seleziona file</button>
      </div>

      <ul id="queue" class="mt-4 space-y-2 text-sm"></ul>

      <input id="uploader" type="file" multiple
             accept=".txt,.md,.pdf,.docx,.mp3,.m4a,.wav,.ogg,.webm"
             class="hidden" />
    </section>

    <!-- Anteprima -->
    <section class="bg-white rounded-2xl shadow p-5 mb-6">
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-lg font-semibold">Anteprima</h2>
        <button id="btnClearPreview" class="px-3 py-2 rounded-lg text-sm bg-slate-100 hover:bg-slate-200">Pulisci anteprima</button>
      </div>
      <div id="preview"
           class="prose max-w-none border border-slate-200 rounded-xl p-4 bg-slate-50 text-sm">
        <p class="text-slate-500">L’anteprima comparirà qui…</p>
      </div>
    </section>

    <!-- Appunti -->
    <section class="bg-white rounded-2xl shadow p-5 mb-6">
      <h2 class="text-lg font-semibold mb-3">Appunti</h2>
      <textarea id="notes" rows="12"
        class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
        placeholder="Appunti trascritti o estratti…"></textarea>

      <div class="mt-4 flex flex-wrap gap-2">
        <!-- Pulsanti rapidi -->
        <button id="btnClean"
          class="px-3 py-2 rounded-lg text-sm bg-slate-100 hover:bg-slate-200">Pulizia</button>
        <button id="btnMinutesAI"
          class="px-3 py-2 rounded-lg text-sm bg-slate-100 hover:bg-slate-200">Verbale</button>
        <button id="btnTranscribe"
          class="px-3 py-2 rounded-lg text-sm bg-slate-100 hover:bg-slate-200">Trascrizione</button>

        <!-- Storico -->
        <button id="btnGenerate"
          class="px-3 py-2 rounded-lg text-sm bg-blue-600 text-white hover:bg-blue-700">
          Genera verbale
        </button>
        <button id="btnReset"
          class="px-3 py-2 rounded-lg text-sm bg-slate-100 hover:bg-slate-200">
          Resettare
        </button>
      </div>
    </section>

    <!-- Analisi intelligente -->
    <section class="bg-white rounded-2xl shadow p-5 mb-6">
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-lg font-semibold">Analisi intelligente</h2>
        <div class="flex flex-wrap gap-2">
          <button id="btnSummarize"   class="px-3 py-2 rounded-lg text-sm bg-slate-100 hover:bg-slate-200">Riassunto</button>
          <button id="btnHighlights"  class="px-3 py-2 rounded-lg text-sm bg-slate-100 hover:bg-slate-200">Punti salienti</button>
          <button id="btnTodos"       class="px-3 py-2 rounded-lg text-sm bg-slate-100 hover:bg-slate-200">To-Do</button>
          <button id="btnSuggestTags" class="px-3 py-2 rounded-lg text-sm bg-slate-100 hover:bg-slate-200">Suggerisci tag</button>
        </div>
      </div>

      <div class="grid gap-4 md:grid-cols-2">
        <div class="border border-slate-200 rounded-xl p-3 bg-slate-50">
          <h3 class="font-medium mb-2">Riassunto</h3>
          <div id="summaryBox" class="text-sm text-slate-800 whitespace-pre-wrap">—</div>
        </div>
        <div class="border border-slate-200 rounded-xl p-3 bg-slate-50">
          <h3 class="font-medium mb-2">Punti salienti</h3>
          <div id="highlightsBox" class="text-sm text-slate-800 whitespace-pre-wrap">—</div>
        </div>
        <div class="border border-slate-200 rounded-xl p-3 bg-slate-50">
          <h3 class="font-medium mb-2">To-Do</h3>
          <div id="todoBox" class="text-sm text-slate-800 whitespace-pre-wrap">—</div>
        </div>
        <div class="border border-slate-200 rounded-xl p-3 bg-slate-50">
          <h3 class="font-medium mb-2">Tag suggeriti</h3>
          <div id="tagsBox" class="text-sm text-slate-800 whitespace-pre-wrap">—</div>
        </div>
      </div>
    </section>

    <!-- Verbale -->
    <section class="bg-white rounded-2xl shadow p-5">
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-lg font-semibold">Verbale</h2>
        <div class="flex gap-2">
          <button id="btnCopy" class="px-3 py-2 rounded-lg text-sm bg-slate-100 hover:bg-slate-200">Copiare</button>
          <button id="btnDownload" class="px-3 py-2 rounded-lg text-sm bg-slate-100 hover:bg-slate-200">Scarica .md</button>
        </div>
      </div>
      <pre id="result" class="whitespace-pre-wrap text-sm leading-6 text-slate-800">Il verbale comparirà qui…</pre>
    </section>
  </div>

  <script>
    /* ---------- helpers UI ---------- */
    const $ = (s) => document.querySelector(s);
    const queueEl   = $('#queue');
    const previewEl = $('#preview');

    function addQueueRow(name, meta, status) {
      const li = document.createElement('li');
      li.className = "border rounded-lg px-3 py-2 flex items-center justify-between";
      li.dataset.name = name;
      li.innerHTML = `
        <div>
          <div class="font-medium">${name}</div>
          <div class="text-slate-500 text-xs">${meta} · <span class="status">${status}</span></div>
        </div>`;
      queueEl.appendChild(li);
      return li;
    }
    function setRowStatus(li, status, danger=false) {
      const s = li.querySelector('.status');
      s.textContent = status;
      s.className = "status " + (danger ? "text-red-500" : "text-slate-500");
    }
    function clearQueue() { queueEl.innerHTML = ''; }

    function appendToNotes(header, text) {
      const ta = $('#notes');
      const section = (header ? `[${header}]\n` : '') + (text || '');
      ta.value = (ta.value ? ta.value + '\n---\n' : '') + section;
    }
    function setPreviewHTML(html) {
      previewEl.innerHTML = html || `<p class="text-slate-500">L’anteprima comparirà qui…</p>`;
    }
    function escapeHTML(s='') {
      return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
    }
    function arrayBufferToDataURL(ab, mime='application/pdf') {
      const bytes = new Uint8Array(ab);
      let bin = '';
      for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
      const b64 = btoa(bin);
      return `data:${mime};base64,${b64}`;
    }

    /* ---------- health check ---------- */
    async function health() {
      const badge = $('#healthBadge');
      try {
        const b = await fetch('/api/blob-url'); // stub ok
        const e = await fetch('/api/extract');  // GET ok
        if (b.ok && e.ok) {
          badge.textContent = 'API ok';
          badge.className = "text-xs px-2.5 py-1 rounded-full bg-emerald-100 text-emerald-700";
        } else {
          badge.textContent = 'API parziali';
          badge.className = "text-xs px-2.5 py-1 rounded-full bg-amber-100 text-amber-700";
        }
      } catch {
        badge.textContent = 'API offline';
        badge.className = "text-xs px-2.5 py-1 rounded-full bg-rose-100 text-rose-700";
      }
    }

    /* ---------- API helpers ---------- */
    async function getUploadUrl() {
      const r = await fetch('/api/blob-url');
      if (!r.ok) throw new Error('blob-url non disponibile');
      const j = await r.json();
      if (!j.uploadUrl) throw new Error('uploadUrl mancante');
      return j.uploadUrl;
    }
    async function uploadToBlob(uploadUrl, file) {
      const fd = new FormData();
      fd.append('file', file, file.name || 'file');
      const r = await fetch(uploadUrl, { method: 'POST', body: fd });
      const j = await r.json().catch(()=> ({}));
      if (!r.ok || !j?.url) throw new Error(j?.message || 'Upload fallito');
      return j.url;
    }
    async function extractWithUrl(blobUrl, name) {
      // Non usata per PDF (per essi usiamo dataURL), utile in futuro se avrai un vero blob server.
      const r = await fetch('/api/extract', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ fileUrl: blobUrl, fileName: name })
      });
      const j = await r.json().catch(()=> ({}));
      if (!r.ok) throw new Error(j?.message || 'Errore estrazione');
      return j.text || j.content || j.result || '';
    }
    async function transcribeWithUrl(blobUrl) {
      const r = await fetch('/api/whisper', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url: blobUrl })
      });
      const j = await r.json().catch(()=> ({}));
      if (!r.ok || !j?.ok) throw new Error(j?.message || 'Errore trascrizione');
      return j.text || '';
    }

    /* ---------- Fallback locali (pulsanti rapidi) ---------- */
    function cleanText(t="") {
      return t.replace(/\r/g,"")
        .replace(/[ \t]+\n/g,"\n")
        .replace(/\n{3,}/g,"\n\n")
        .replace(/[ \t]{2,}/g," ")
        .trim();
    }
    function toMinutes(t="") {
      const lines = cleanText(t).split("\n").filter(Boolean);
      const bullets = lines.map(l => `- ${l.trim()}`).join("\n");
      const date = new Date().toLocaleString();
      return `# Verbale\n_Data:_ ${date}\n\n## Punti trattati\n${bullets}\n`;
    }
    function toTranscriptLocal(t="") {
      return cleanText(
        t
          .replace(/\[?\(?\b\d{1,2}:\d{2}(?::\d{2})?\)?\]?/g, "")
          .replace(/\b(eh+m*|mm+|mah|cioè|tipo|allora)\b/gi, "")
          .replace(/(?:\n?\s*[•\-–]\s+)/g, "\n")
      );
    }
    async function callTextAPI(endpoints=[], payload) {
      for (const ep of endpoints) {
        try {
          const r = await fetch(ep, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          const j = await r.json().catch(()=> ({}));
          if (r.ok) {
            const out = j.text || j.verbale || j.content || j.result || "";
            if (out && typeof out === "string") return out;
          }
        } catch { /* prova il prossimo */ }
      }
      return "";
    }

    async function runNotesAction(kind) {
      const ta = $('#notes');
      const src = ta.value.trim();
      if (!src) { alert("Incolla o scrivi del testo negli Appunti prima."); return; }

      const btnSel = ["#btnClean","#btnMinutesAI","#btnTranscribe","#btnGenerate"];
      const disable = (v)=>btnSel.forEach(s=>{const b=document.querySelector(s); if(b) b.disabled=v;});
      disable(true);

      try {
        let out = "";

        if (kind === "cleanup") {
          out = await callTextAPI(["/api/cleanup"], { notes: src });
          if (!out) out = cleanText(src);
          ta.value = out;
          document.querySelector("#result").textContent = out;

        } else if (kind === "minutes") {
          out = await callTextAPI(["/api/minutes","/api/format","/api/verbale"], { notes: src });
          if (!out) out = toMinutes(src);
          document.querySelector("#result").textContent = out;

        } else if (kind === "transcript") {
          out = await callTextAPI(["/api/cleanup"], { notes: src, mode: "transcript" });
          if (!out) out = toTranscriptLocal(src);
          ta.value = out;
          document.querySelector("#result").textContent = out;
        }
      } finally {
        disable(false);
      }
    }

    /* ---------- NLP leggera client-side (Analisi intelligente) ---------- */
    function splitSentences(t="") {
      return t
        .replace(/\s+/g, " ")
        .split(/(?<=[\.\?\!])\s+(?=[A-ZÀ-Ú])/g)
        .map(s => s.trim())
        .filter(Boolean);
    }
    function summarizeText(t="", maxSentences=5) {
      const cues = [
        "decisione","decide","delibera","approva","stabilisce","si conviene",
        "scadenza","entro","termine","deadline","consegna",
        "responsabile","incarica","assegnato","owner",
        "bilancio","budget","priorità","urgente","importante"
      ];
      const sents = splitSentences(cleanText(t));
      if (!sents.length) return "";
      const scores = sents.map((s,i) => {
        const lc = s.toLowerCase();
        const cueScore = cues.reduce((acc,w)=> acc + (lc.includes(w)?1:0), 0);
        const posScore = (i===0?1:0) + (i===sents.length-1?0.5:0);
        const lenScore = Math.min(s.length/120, 1);
        return { s, score: cueScore*2 + posScore + lenScore*0.5 };
      });
      scores.sort((a,b)=> b.score - a.score);
      return scores.slice(0, maxSentences).map(x=>x.s).join(" ");
    }
    function extractHighlights(t="") {
      const txt = cleanText(t);
      const decisions = [];
      const deadlines = [];
      const owners = [];
      const lines = txt.split("\n").map(l=>l.trim()).filter(Boolean);
      const reDate = /\b(\d{1,2}[\/\.-]\d{1,2}[\/\.-]\d{2,4}|(?:\d{1,2}\s+(?:gen|feb|mar|apr|mag|giu|lug|ago|set|ott|nov|dic)[a-z]*\s+\d{4}))\b/gi;

      for (const l of lines) {
        const ll = l.toLowerCase();
        if (/(delibera|si decide|si stabilisce|si approva|viene approvato|si conviene)/i.test(ll)) {
          decisions.push(l);
        }
        if (/(entro|scadenza|termine|deadline|entro e non oltre|per il|entro il)/i.test(ll)) {
          const dateMatch = l.match(reDate)?.[0] || "";
          deadlines.push(dateMatch ? `${l} (data: ${dateMatch})` : l);
        }
        const m1 = l.match(/responsabile\s*:\s*(.+)$/i);
        const m2 = l.match(/a cura di\s+(.+)$/i);
        const m3 = l.match(/si incarica\s+([A-ZÀ-Ú][A-Za-zÀ-ÿ'’\- ]+)\s+di/i);
        const m4 = l.match(/assegnat[oa]\s+a\s+([A-ZÀ-Ú][A-Za-zÀ-ÿ'’\- ]+)/i);
        if (m1) owners.push(m1[1].trim());
        else if (m2) owners.push(m2[1].trim());
        else if (m3) owners.push(m3[1].trim());
        else if (m4) owners.push(m4[1].trim());
      }
      return {
        decisions: [...new Set(decisions)],
        deadlines: [...new Set(deadlines)],
        owners:    [...new Set(owners)],
      };
    }
    function extractActions(t="") {
      const txt = cleanText(t);
      const lines = txt.split("\n").map(l=>l.trim()).filter(Boolean);
      const verbs = /(inviare|invia|preparare|prepara|contattare|contatta|verificare|verifica|aggiornare|aggiorna|convocare|convoca|pagare|paga|richiedere|richiede|redigere|redigi|prenotare|prenota|organizzare|organizza|acquistare|acquista|fare|fai|eseguire|esegue)/i;
      const reDate = /\b(\d{1,2}[\/\.-]\d{1,2}[\/\.-]\d{2,4}|(?:\d{1,2}\s+(?:gen|feb|mar|apr|mag|giu|lug|ago|set|ott|nov|dic)[a-z]*\s+\d{4}))\b/gi;

      const items = [];
      for (const l of lines) {
        if (l.startsWith("-") || l.startsWith("•") || verbs.test(l)) {
          const due = l.match(reDate)?.[0] || (/(entro|deadline|scadenza|termine)/i.test(l) ? "entro (data da definire)" : "");
          const owner = (l.match(/(?:da|a|per)\s+([A-ZÀ-Ú][A-Za-zÀ-ÿ'’\- ]+)\b/)||[])[1] ||
                        (l.match(/(?:responsabile|assegnat[oa])\s*:\s*([A-ZÀ-Ú][A-Za-zÀ-ÿ'’\- ]+)/i)||[])[1] || "";
          items.push({
            task: l.replace(/^[\-\•]\s*/, ""),
            owner: owner || null,
            due: due   || null
          });
        }
      }
      const seen = new Set();
      return items.filter(it => {
        const k = `${it.task}|${it.owner||""}|${it.due||""}`.toLowerCase();
        if (seen.has(k)) return false;
        seen.add(k);
        return true;
      });
    }
    function suggestTags(t="") {
      const lc = t.toLowerCase();
      const TAGS = {
        Bilancio: ["bilancio","consuntivo","preventivo","spese","budget","quote","riparto"],
        Lavori:   ["lavori","manutenzione","appalto","impresa","cantiere","capitolato"],
        Convocazione: ["convocazione","ordine del giorno","odg","assemblea","verbale"],
        Fornitori: ["fornitore","fornitori","preventivo","offerta","contratto","fattura"],
        Sicurezza: ["sicurezza","incendio","impianto","adeguamento","certificazione"],
        Pagamenti: ["pagare","pagamento","mav","bonifico","morosità","sollecito"],
      };
      const out = [];
      for (const [tag, kws] of Object.entries(TAGS)) {
        if (kws.some(k => lc.includes(k))) out.push(tag);
      }
      return out.length ? out : ["Generale"];
    }
    function renderList(el, arr, bullet="- ") {
      el.textContent = arr?.length ? arr.map(x=> bullet + x).join("\n") : "—";
    }
    function renderTodos(el, items) {
      if (!items?.length) { el.textContent = "—"; return; }
      el.textContent = items.map(it => {
        const who = it.owner ? ` [${it.owner}]` : "";
        const due = it.due ? ` (scad.: ${it.due})` : "";
        return `□ ${it.task}${who}${due}`;
      }).join("\n");
    }

    /* ---------- Fallback: testo PDF locale ---------- */
    async function extractPdfTextLocal(arrayBuffer, maxPages = 8) {
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      let out = '';
      const n = Math.min(pdf.numPages, maxPages);
      for (let i = 1; i <= n; i++) {
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();
        const line = content.items.map(it => it.str).join(' ');
        out += line + '\n\n';
      }
      if (pdf.numPages > n) {
        out += `\n[... testo troncato a ${n}/${pdf.numPages} pagine ...]\n`;
      }
      return out.trim();
    }

    /* ---------- Gestione file & anteprima ---------- */
    async function handleFiles(files) {
      for (const file of files) {
        const name = file.name || 'file';
        const ext  = (name.split('.').pop() || '').toLowerCase();
        const meta = `${file.type || '(sconosciuto)'} · ${new Intl.NumberFormat('it-IT').format(file.size)} B`;
        const li = addQueueRow(name, meta, 'in coda…');

        try {
          const isText  = ['txt','md'].includes(ext);
          const isDocx  = ext === 'docx';
          const isPdf   = ext === 'pdf';
          const isAudio = ['mp3','m4a','wav','ogg','webm'].includes(ext);

          /* TXT/MD → anteprima & appunti locali */
          if (isText) {
            setRowStatus(li, 'lettura locale…');
            const t = await file.text();
            setPreviewHTML(`<pre style="white-space:pre-wrap;">${escapeHTML(t)}</pre>`);
            appendToNotes(`Testo locale: ${name}`, t);
            setRowStatus(li, 'anteprima pronta');
            continue;
          }

          /* DOCX → anteprima & appunti con Mammoth */
          if (isDocx) {
            setRowStatus(li, 'conversione .docx…');
            const arrayBuffer = await file.arrayBuffer();
            const { value: html } = await window.mammoth.convertToHtml({ arrayBuffer }, {
              styleMap: [
                "p[style-name='Title'] => h1:fresh",
                "p[style-name='Heading 1'] => h2:fresh",
                "p[style-name='Heading 2'] => h3:fresh",
              ],
            });
            setPreviewHTML(html || `<p>(Documento vuoto)</p>`);
            const tmp = document.createElement('div'); tmp.innerHTML = html;
            appendToNotes(`Estratto (locale): ${name}`, (tmp.textContent || tmp.innerText || '').trim());
            setRowStatus(li, 'anteprima pronta');
            continue;
          }

          /* PDF → preview 1ª pagina + estrazione via /api/extract (dataURL) con fallback locale */
          if (isPdf) {
            setRowStatus(li, 'anteprima PDF…');

            // Render 1ª pagina (locale)
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            const page = await pdf.getPage(1);
            const viewport = page.getViewport({ scale: 1.2 });
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.height = viewport.height;
            canvas.width  = viewport.width;
            await page.render({ canvasContext: ctx, viewport }).promise;
            setPreviewHTML("");
            previewEl.appendChild(canvas);

            // Estrazione testo → dataURL → /api/extract
            setRowStatus(li, 'estrazione testo…');
            let text = '';
            try {
              const dataURL = arrayBufferToDataURL(arrayBuffer, 'application/pdf');
              const r = await fetch('/api/extract', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ dataURL, fileName: name })
              });
              const j = await r.json().catch(()=> ({}));
              if (!r.ok) throw new Error(j?.message || 'Errore estrazione');
              text = j.text || '';
            } catch (e) {
              console.warn('Estrazione server fallita, fallback locale:', e);
            }

            // Fallback locale se necessario
            if (!text || !text.trim()) {
              setRowStatus(li, 'estrazione locale…');
              text = await extractPdfTextLocal(arrayBuffer, 8);
            }

            appendToNotes(`Estratto: ${name}`, text || '(nessun testo)');
            setRowStatus(li, 'estratto');
            continue;
          }

          /* Audio → pipeline server (trascrizione) */
          if (isAudio) {
            setRowStatus(li, 'trascrizione…');
            const uploadUrl = await getUploadUrl();
            const blobUrl   = await uploadToBlob(uploadUrl, file);
            const text      = await transcribeWithUrl(blobUrl);
            appendToNotes(`Trascrizione: ${name}`, text);
            setRowStatus(li, 'trascritto');
            continue;
          }

          setRowStatus(li, 'formato non supportato', true);
        } catch (e) {
          console.error(e);
          setRowStatus(li, e.message || 'errore', true);
          alert(`${name}: ${e.message || 'Errore'}`);
        }
      }
